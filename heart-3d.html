<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D 跳動發光愛心</title>
  <style>
    :root { color-scheme: dark; }

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
    }

    body {
      overflow: hidden;
      /* 背景：深藍向內漸變淺藍 */
      background: radial-gradient(circle at 50% 45%,
        #93c7ff 0%,
        #2b6bd6 42%,
        #071a3a 100%
      );
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    /* 避免選取拖曳 */
    * { -webkit-user-select: none; user-select: none; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js";
    import { MeshSurfaceSampler } from "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/math/MeshSurfaceSampler.js";

    // ---------- Renderer / Scene / Camera ----------
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      200
    );
    camera.position.set(0, 0.6, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setClearColor(0x000000, 0); // 透明，讓 CSS 背景漸變透出
    document.body.appendChild(renderer.domElement);

    // ---------- Lights ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.25);
    keyLight.position.set(3, 4, 5);
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0x9fd6ff, 0.45);
    fillLight.position.set(-4, -1, 3);
    scene.add(fillLight);

    const rimLight = new THREE.DirectionalLight(0xff99aa, 0.75);
    rimLight.position.set(-4, 2, -4);
    scene.add(rimLight);

    // ---------- 3D Heart (Shape + ExtrudeGeometry) ----------
    const heartShape = new THREE.Shape();
    const x = 0, y = 0;

    // 經典 heart shape（用 bezier 曲線勾勒）
    heartShape.moveTo(x + 5, y + 5);
    heartShape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
    heartShape.bezierCurveTo(x - 6, y, x - 6, y + 7, x - 6, y + 7);
    heartShape.bezierCurveTo(x - 6, y + 11, x - 3, y + 15, x + 5, y + 19);
    heartShape.bezierCurveTo(x + 12, y + 15, x + 16, y + 11, x + 16, y + 7);
    heartShape.bezierCurveTo(x + 16, y + 7, x + 16, y, x + 10, y);
    heartShape.bezierCurveTo(x + 7, y, x + 5, y + 5, x + 5, y + 5);

    const heartGeo = new THREE.ExtrudeGeometry(heartShape, {
      depth: 4,
      steps: 2,
      bevelEnabled: true,
      bevelThickness: 1.7,
      bevelSize: 1.25,
      bevelOffset: 0,
      bevelSegments: 6,
    });
    heartGeo.center();

    const heartMat = new THREE.MeshPhysicalMaterial({
      color: 0xff1e2d,          // 紅色
      roughness: 0.22,
      metalness: 0.05,
      clearcoat: 0.75,
      clearcoatRoughness: 0.18,
    });

    const heartMesh = new THREE.Mesh(heartGeo, heartMat);

    // 用 Group 包起來，讓粒子也可以一起跟著動
    const heart = new THREE.Group();
    heart.add(heartMesh);
    heart.rotation.x = 0.25; // 輕微仰角
    scene.add(heart);

    const baseScale = 0.12;
    heart.scale.setScalar(baseScale);

    // ---------- Glowy Particles (3D) ----------
    function makeRadialGlowTexture({
      size = 128,
      innerColor = "rgba(255,255,255,1)",
      midColor = "rgba(255,255,255,0.35)",
      outerColor = "rgba(255,255,255,0)",
    } = {}) {
      const c = document.createElement("canvas");
      c.width = c.height = size;
      const gctx = c.getContext("2d");
      const g = gctx.createRadialGradient(size * 0.5, size * 0.5, 0, size * 0.5, size * 0.5, size * 0.5);
      g.addColorStop(0.0, innerColor);
      g.addColorStop(0.35, midColor);
      g.addColorStop(1.0, outerColor);
      gctx.fillStyle = g;
      gctx.fillRect(0, 0, size, size);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.needsUpdate = true;
      return tex;
    }

    const blueSprite = makeRadialGlowTexture({
      innerColor: "rgba(200,245,255,1)",
      midColor: "rgba(120,210,255,0.35)",
      outerColor: "rgba(120,210,255,0)",
    });

    const whiteSprite = makeRadialGlowTexture({
      innerColor: "rgba(255,255,255,1)",
      midColor: "rgba(255,255,255,0.35)",
      outerColor: "rgba(255,255,255,0)",
    });

    // 1) 全場景淡藍發光粒子（3D volume）
    const ambientCount = 2600;
    const ambientBox = new THREE.Vector3(42, 26, 42);
    const half = ambientBox.clone().multiplyScalar(0.5);

    const ambientGeo = new THREE.BufferGeometry();
    const ambientPos = new Float32Array(ambientCount * 3);
    const ambientVel = new Float32Array(ambientCount * 3);
    const ambientCol = new Float32Array(ambientCount * 3);

    for (let i = 0; i < ambientCount; i++) {
      const ix = i * 3;
      ambientPos[ix + 0] = (Math.random() - 0.5) * ambientBox.x;
      ambientPos[ix + 1] = (Math.random() - 0.5) * ambientBox.y;
      ambientPos[ix + 2] = (Math.random() - 0.5) * ambientBox.z;

      // 偏向上飄 + 少量水平/前後漂移
      ambientVel[ix + 0] = (Math.random() - 0.5) * 0.10;
      ambientVel[ix + 1] = (Math.random() * 0.6 + 0.4) * 0.16;
      ambientVel[ix + 2] = (Math.random() - 0.5) * 0.10;

      const c = new THREE.Color(0x7fe6ff);
      const tint = 0.85 + Math.random() * 0.30;
      ambientCol[ix + 0] = c.r * tint;
      ambientCol[ix + 1] = c.g * tint;
      ambientCol[ix + 2] = c.b * tint;
    }

    ambientGeo.setAttribute("position", new THREE.BufferAttribute(ambientPos, 3));
    ambientGeo.setAttribute("color", new THREE.BufferAttribute(ambientCol, 3));

    const ambientMat = new THREE.PointsMaterial({
      map: blueSprite,
      transparent: true,
      opacity: 0.55,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      size: 0.085,
      sizeAttenuation: true,
      vertexColors: true,
    });

    const ambientPoints = new THREE.Points(ambientGeo, ambientMat);
    scene.add(ambientPoints);

    // 2) 愛心周圍密集白色粒子（從愛心表面取樣，掛在 heart 上跟著動）
    const heartCount = 7000;
    const sampler = new MeshSurfaceSampler(heartMesh).build();

    const heartGeoPts = new THREE.BufferGeometry();
    const heartPos = new Float32Array(heartCount * 3);
    const heartBase = new Float32Array(heartCount * 3);
    const heartNrm = new Float32Array(heartCount * 3);
    const heartPhase = new Float32Array(heartCount);
    const heartCol = new Float32Array(heartCount * 3);

    const _p = new THREE.Vector3();
    const _n = new THREE.Vector3();

    // 取樣心形表面點 + 法線，做出貼著 3D 愛心的「白色發光粒子雲」
    for (let i = 0; i < heartCount; i++) {
      const ix = i * 3;
      sampler.sample(_p, _n);

      heartPos[ix + 0] = heartBase[ix + 0] = _p.x;
      heartPos[ix + 1] = heartBase[ix + 1] = _p.y;
      heartPos[ix + 2] = heartBase[ix + 2] = _p.z;

      heartNrm[ix + 0] = _n.x;
      heartNrm[ix + 1] = _n.y;
      heartNrm[ix + 2] = _n.z;

      heartPhase[i] = Math.random() * Math.PI * 2;
      const w = 0.85 + Math.random() * 0.25;
      heartCol[ix + 0] = w;
      heartCol[ix + 1] = w;
      heartCol[ix + 2] = w;
    }

    heartGeoPts.setAttribute("position", new THREE.BufferAttribute(heartPos, 3));
    heartGeoPts.setAttribute("color", new THREE.BufferAttribute(heartCol, 3));

    const heartMatPts = new THREE.PointsMaterial({
      map: whiteSprite,
      transparent: true,
      opacity: 0.95,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      size: 0.065,
      sizeAttenuation: true,
      vertexColors: true,
    });

    const heartPoints = new THREE.Points(heartGeoPts, heartMatPts);
    heartPoints.frustumCulled = false;
    heart.add(heartPoints);

    // ---------- Animation ----------
    const clock = new THREE.Clock();

    function heartbeatScale(t) {
      // 兩次短峰：模擬「咚-咚」，並加入放鬆期，讓心臟有輕微收縮（scale < 1）
      const speed = 3.2;
      const b1 = Math.pow(Math.max(0, Math.sin(t * speed)), 6);
      const b2 = Math.pow(Math.max(0, Math.sin(t * speed + 1.1)), 10);
      const relax = Math.pow(Math.max(0, Math.sin(t * speed + Math.PI * 0.75)), 2);
      return 1 + 0.11 * (b1 + 0.6 * b2) - 0.045 * relax;
    }

    function animate() {
      requestAnimationFrame(animate);

      // 注意：Clock.getElapsedTime() 內部會呼叫 getDelta() 並更新 oldTime。
      // 若先 getElapsedTime() 再 getDelta()，dt 會趨近 0，導致背景粒子幾乎不動。
      const dt = Math.min(0.05, clock.getDelta());
      const t = clock.elapsedTime;

      // 讓鏡頭輕微繞行，增加「立體」視差感
      camera.position.x = Math.sin(t * 0.25) * 0.35;
      camera.position.y = 0.6 + Math.sin(t * 0.18) * 0.08;
      camera.lookAt(0, 0, 0);

      // 心跳（收縮跳動）+ 輕微自轉
      const pulse = heartbeatScale(t);
      heart.scale.setScalar(baseScale * pulse);
      heart.rotation.y = t * 0.65;
      heart.rotation.z = 0.12 * Math.sin(t * 0.8);

      // 背景 3D 粒子漂浮（wrap）
      const pos = ambientGeo.attributes.position.array;
      for (let i = 0; i < ambientCount; i++) {
        const ix = i * 3;
        pos[ix + 0] += ambientVel[ix + 0] * (dt * 60);
        pos[ix + 1] += ambientVel[ix + 1] * (dt * 60);
        pos[ix + 2] += ambientVel[ix + 2] * (dt * 60);

        if (pos[ix + 0] > half.x) pos[ix + 0] = -half.x;
        if (pos[ix + 0] < -half.x) pos[ix + 0] = half.x;
        if (pos[ix + 1] > half.y) pos[ix + 1] = -half.y;
        if (pos[ix + 1] < -half.y) pos[ix + 1] = half.y;
        if (pos[ix + 2] > half.z) pos[ix + 2] = -half.z;
        if (pos[ix + 2] < -half.z) pos[ix + 2] = half.z;
      }
      ambientGeo.attributes.position.needsUpdate = true;

      // 愛心周圍粒子：沿法線做微小呼吸抖動（會隨心跳縮放一起動）
      const hp = heartGeoPts.attributes.position.array;
      const jitterAmp = 0.65;
      const jitterFreq = 1.35;
      for (let i = 0; i < heartCount; i++) {
        const ix = i * 3;
        const s = Math.sin(t * jitterFreq + heartPhase[i]);
        const amp = jitterAmp * (0.5 + 0.5 * s);
        hp[ix + 0] = heartBase[ix + 0] + heartNrm[ix + 0] * amp;
        hp[ix + 1] = heartBase[ix + 1] + heartNrm[ix + 1] * amp;
        hp[ix + 2] = heartBase[ix + 2] + heartNrm[ix + 2] * amp;
      }
      heartGeoPts.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }
    animate();

    // ---------- Resize ----------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    }, { passive: true });
  </script>
</body>
</html>
