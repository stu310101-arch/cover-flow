<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>3D 跳動發光愛心</title>
  <style>
    :root { color-scheme: dark; }

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
    }

    body {
      overflow: hidden;
      background: #020612;
      font-family: system-ui, -apple-system, "Segoe UI", "Noto Sans TC", sans-serif;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      display: block;
      background: transparent;
    }

    #overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: grid;
      place-items: center;
      background: #020612;
      color: rgba(255,255,255,0.92);
    }

    #overlay.hide {
      opacity: 0;
      transition: opacity 300ms ease;
      pointer-events: none;
    }

    #overlay .box {
      padding: 14px 16px;
      border-radius: 14px;
      background: rgba(2, 8, 20, 0.45);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      text-align: center;
      max-width: min(520px, calc(100vw - 28px));
      line-height: 1.5;
    }

    #overlay .title {
      font-size: 15px;
      font-weight: 650;
      letter-spacing: 0.2px;
    }

    #overlay .desc {
      margin-top: 6px;
      font-size: 12px;
      color: rgba(255,255,255,0.72);
      white-space: pre-line;
    }

    /* 避免選取拖曳 */
    * { -webkit-user-select: none; user-select: none; }
  </style>

  <!--
    Module 版本（不依賴 importmap）：
    - 直接用 esm.sh 匯入 three 與 examples/jsm addons
    - iOS Safari/Chrome 對 importmap 支援不完整時，也能正常載入
  -->
</head>
<body>
  <div id="overlay" role="status" aria-live="polite">
    <div class="box">
      <div class="title">載入中…</div>
      <div class="desc">正在載入 3D 模組</div>
    </div>
  </div>

  <script>
    (function () {
      const overlay = document.getElementById("overlay");
      if (!overlay) return;

      window.setTimeout(() => {
        if (window.__HEART_OK__ || window.__HEART_FAILED__) return;

        const tried = Array.isArray(window.__HEART_CDNS_TRIED__) && window.__HEART_CDNS_TRIED__.length
          ? window.__HEART_CDNS_TRIED__
          : ["esm.sh", "jsdelivr"];

        const titleEl = overlay.querySelector(".title");
        const descEl = overlay.querySelector(".desc");
        if (titleEl) titleEl.textContent = "3D 模組載入逾時";
        if (descEl) descEl.textContent = `3D 模組載入逾時：仍無法連線到 CDN（${tried.join("、")}）。請確認網路環境或稍後再試。`;
      }, 15000);
    })();
  </script>

  <script type="module">
    const overlayEl = document.getElementById("overlay");

    function setOverlayText(title, desc) {
      if (!overlayEl) return;
      const titleEl = overlayEl.querySelector(".title");
      const descEl = overlayEl.querySelector(".desc");
      if (titleEl) titleEl.textContent = title;
      if (descEl) descEl.textContent = desc;
    }

    function showOverlayError(triedNames) {
      window.__HEART_FAILED__ = true;
      const triedText = (Array.isArray(triedNames) && triedNames.length)
        ? triedNames.join("、")
        : "esm.sh、jsdelivr";

      setOverlayText(
        "3D 模組載入失敗",
        `3D 模組載入失敗：無法載入 CDN（${triedText}）。請確認網路環境或稍後再試。`
      );
    }

    function appendOverlayErrorMessage(err) {
      if (!overlayEl) return;
      const descEl = overlayEl.querySelector(".desc");
      if (!descEl) return;

      const msg = err && err.message ? String(err.message) : "";
      if (!msg) return;

      const shortMsg = msg.length > 160 ? `${msg.slice(0, 160)}…` : msg;
      descEl.textContent += `\n錯誤：${shortMsg}`;
    }

    const CDN_FALLBACKS = [
      {
        name: "esm.sh",
        three: "https://esm.sh/three@0.182.0",
        effectComposer: "https://esm.sh/three@0.182.0/examples/jsm/postprocessing/EffectComposer.js",
        renderPass: "https://esm.sh/three@0.182.0/examples/jsm/postprocessing/RenderPass.js",
        unrealBloomPass: "https://esm.sh/three@0.182.0/examples/jsm/postprocessing/UnrealBloomPass.js",
        outputPass: "https://esm.sh/three@0.182.0/examples/jsm/postprocessing/OutputPass.js",
      },
      {
        name: "jsdelivr",
        three: "https://cdn.jsdelivr.net/npm/three@0.182.0/+esm",
        effectComposer: "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/postprocessing/EffectComposer.js/+esm",
        renderPass: "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/postprocessing/RenderPass.js/+esm",
        unrealBloomPass: "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/postprocessing/UnrealBloomPass.js/+esm",
        outputPass: "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/postprocessing/OutputPass.js/+esm",
      },
    ];

    async function importWithTimeout(url, timeoutMs) {
      const p = import(url);
      p.catch(() => {});

      let timeoutId;
      const timeoutPromise = new Promise((_, reject) => {
        timeoutId = window.setTimeout(() => reject(new Error(`Timeout while importing: ${url}`)), timeoutMs);
      });

      const result = await Promise.race([p, timeoutPromise]);
      window.clearTimeout(timeoutId);
      return result;
    }

    async function loadThreeModules() {
      const tried = [];
      window.__HEART_CDNS_TRIED__ = tried;

      const timeoutMs = 5500;

      for (const cdn of CDN_FALLBACKS) {
        tried.push(cdn.name);
        setOverlayText("載入中…", `正在嘗試載入 3D 模組（${cdn.name}）`);

        try {
          const [
            THREE,
            { EffectComposer },
            { RenderPass },
            { UnrealBloomPass },
            { OutputPass },
          ] = await Promise.all([
            importWithTimeout(cdn.three, timeoutMs),
            importWithTimeout(cdn.effectComposer, timeoutMs),
            importWithTimeout(cdn.renderPass, timeoutMs),
            importWithTimeout(cdn.unrealBloomPass, timeoutMs),
            importWithTimeout(cdn.outputPass, timeoutMs),
          ]);

          return { THREE, EffectComposer, RenderPass, UnrealBloomPass, OutputPass };
        } catch (err) {
          console.warn(`[heart-3d] CDN 失敗：${cdn.name}`, err);
        }
      }

      showOverlayError(tried);
      throw new Error(`Failed to load three modules from: ${tried.join(", ")}`);
    }

    (async () => {
      const { THREE, EffectComposer, RenderPass, UnrealBloomPass, OutputPass } = await loadThreeModules();

      function hideOverlay() {
        if (!overlayEl) return;
        overlayEl.classList.add("hide");
        window.setTimeout(() => overlayEl.remove(), 380);
      }

      const isMobile = matchMedia("(max-width: 768px)").matches;
      const dprCap = isMobile ? 1.5 : 2;

      const COUNTS = {
        heartFill: isMobile ? 11000 : 20000,
        heartEdge: isMobile ? 2400 : 4200,
        outerDust: isMobile ? 7000 : 14000,
      };

      // ---------- Renderer / Scene / Camera ----------
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020612);

      const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 200);
      camera.position.set(0, 0.55, 4.6);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, dprCap));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.18;
      renderer.setClearColor(0x020612, 1);
      document.body.appendChild(renderer.domElement);

      // ---------- Postprocessing (Bloom) ----------
      const BLOOM = {
        strength: 0.85,
        radius: 0.18,
        threshold: 0.74,
      };

      const composer = new EffectComposer(renderer);
      composer.setPixelRatio(Math.min(window.devicePixelRatio || 1, dprCap));
      composer.addPass(new RenderPass(scene, camera));

      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        BLOOM.strength,
        BLOOM.radius,
        BLOOM.threshold
      );
      composer.addPass(bloomPass);
      composer.addPass(new OutputPass());

      // ---------- Sprite ----------
      function makeDotTexture({ size = 64 } = {}) {
        const c = document.createElement("canvas");
        c.width = c.height = size;

        const ctx = c.getContext("2d");
        ctx.clearRect(0, 0, size, size);

        const r = size * 0.5;
        const g = ctx.createRadialGradient(r, r, 0, r, r, r);
        g.addColorStop(0, "rgba(255,255,255,1)");
        g.addColorStop(0.4, "rgba(255,255,255,1)");
        g.addColorStop(0.75, "rgba(255,255,255,0.25)");
        g.addColorStop(1, "rgba(255,255,255,0)");

        ctx.fillStyle = g;
        ctx.fillRect(0, 0, size, size);

        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.generateMipmaps = false;
        tex.needsUpdate = true;
        return tex;
      }

      function makeGlowTexture({ size = 128 } = {}) {
        const c = document.createElement("canvas");
        c.width = c.height = size;

        const ctx = c.getContext("2d");
        ctx.clearRect(0, 0, size, size);

        const g = ctx.createRadialGradient(
          size * 0.5,
          size * 0.5,
          0,
          size * 0.5,
          size * 0.5,
          size * 0.5
        );
        g.addColorStop(0, "rgba(255,255,255,1)");
        g.addColorStop(0.35, "rgba(255,255,255,0.55)");
        g.addColorStop(1, "rgba(255,255,255,0)");

        ctx.fillStyle = g;
        ctx.fillRect(0, 0, size, size);

        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.generateMipmaps = false;
        tex.needsUpdate = true;
        return tex;
      }

      const dotTex = makeDotTexture({ size: 64 });
      const glowTex = makeGlowTexture({ size: 128 });

      // ---------- Heart (2D shape) ----------
      const heartShape = new THREE.Shape();
      const x = 0, y = 0;

      heartShape.moveTo(x + 5, y + 5);
      heartShape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
      heartShape.bezierCurveTo(x - 6, y, x - 6, y + 7, x - 6, y + 7);
      heartShape.bezierCurveTo(x - 6, y + 11, x - 3, y + 15, x + 5, y + 19);
      heartShape.bezierCurveTo(x + 12, y + 15, x + 16, y + 11, x + 16, y + 7);
      heartShape.bezierCurveTo(x + 16, y + 7, x + 16, y, x + 10, y);
      heartShape.bezierCurveTo(x + 7, y, x + 5, y + 5, x + 5, y + 5);

      const outlinePolyRaw = heartShape.getSpacedPoints(520);
      outlinePolyRaw.pop();
      const outlinePoly = outlinePolyRaw.map((p) => new THREE.Vector2(p.x, p.y));

      const outlineBoxRaw = new THREE.Box2().setFromPoints(outlinePoly);
      const outlineCenter = outlineBoxRaw.getCenter(new THREE.Vector2());

      for (let i = 0; i < outlinePoly.length; i++) {
        outlinePoly[i].sub(outlineCenter);
      }

      const outlineBox = new THREE.Box2().setFromPoints(outlinePoly);

      function isPointInPolygon(p, poly) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i].x, yi = poly[i].y;
          const xj = poly[j].x, yj = poly[j].y;
          const intersect = ((yi > p.y) !== (yj > p.y))
            && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      const MAX_TRIES_IN_POLY = 900;
      const _v2 = new THREE.Vector2();

      function sampleInHeart2D(out) {
        for (let tries = 0; tries < MAX_TRIES_IN_POLY; tries++) {
          out.set(
            THREE.MathUtils.lerp(outlineBox.min.x, outlineBox.max.x, Math.random()),
            THREE.MathUtils.lerp(outlineBox.min.y, outlineBox.max.y, Math.random())
          );
          if (isPointInPolygon(out, outlinePoly)) return out;
        }

        out.set(0, 0);
        return out;
      }

      const heart = new THREE.Group();
      heart.rotation.set(0, 0, Math.PI);
      scene.add(heart);

      const MOBILE_FIT = 0.75;
      const baseScale = 0.12;
      const heartScale = baseScale * (isMobile ? MOBILE_FIT : 1);
      heart.scale.setScalar(heartScale);

      // ---------- Colors (pink / magenta only; tiny hue jitter) ----------
      const _c = new THREE.Color();
      function writePinkColor(dst, ix, lightnessBase, lightnessJitter) {
        const hue = THREE.MathUtils.degToRad(330 + (Math.random() - 0.5) * 16);
        const h = (hue / (Math.PI * 2) + 1) % 1;
        const s = 0.86 + Math.random() * 0.12;
        const l = THREE.MathUtils.clamp(lightnessBase + (Math.random() - 0.5) * lightnessJitter, 0.32, 0.76);
        _c.setHSL(h, s, l, THREE.SRGBColorSpace);
        dst[ix + 0] = _c.r;
        dst[ix + 1] = _c.g;
        dst[ix + 2] = _c.b;
      }

      // ---------- Layer A: heartFill (almost 2D) ----------
      const heartFillCount = COUNTS.heartFill;
      const heartFillGeo = new THREE.BufferGeometry();
      const heartFillPos = new Float32Array(heartFillCount * 3);
      const heartFillCol = new Float32Array(heartFillCount * 3);

      const fillZJitter = 0.06;

      let fillMaxR = 0;
      for (let i = 0; i < outlinePoly.length; i++) {
        fillMaxR = Math.max(fillMaxR, Math.hypot(outlinePoly[i].x, outlinePoly[i].y));
      }

      const FILL_ACCEPT_EXP = 2.6;

      for (let i = 0; i < heartFillCount; i++) {
        const ix = i * 3;

        for (let tries = 0; tries < 2400; tries++) {
          sampleInHeart2D(_v2);
          const rNorm = fillMaxR > 0 ? Math.min(1, Math.hypot(_v2.x, _v2.y) / fillMaxR) : 0;
          const acceptProb = Math.pow(rNorm, FILL_ACCEPT_EXP);
          if (Math.random() < acceptProb) break;
        }

        heartFillPos[ix + 0] = _v2.x;
        heartFillPos[ix + 1] = _v2.y;
        heartFillPos[ix + 2] = (Math.random() - 0.5) * fillZJitter;

        writePinkColor(heartFillCol, ix, 0.58, 0.18);
      }

      const heartFillPosAttr = new THREE.BufferAttribute(heartFillPos, 3);
      heartFillPosAttr.setUsage(THREE.DynamicDrawUsage);
      heartFillGeo.setAttribute("position", heartFillPosAttr);
      heartFillGeo.setAttribute("color", new THREE.BufferAttribute(heartFillCol, 3));

      const heartFillBasePos = heartFillPos.slice();
      const heartFillDir = new Float32Array(heartFillCount * 2);
      const heartFillAmp = new Float32Array(heartFillCount);

      for (let i = 0; i < heartFillCount; i++) {
        const ix = i * 3;
        const px = heartFillBasePos[ix + 0];
        const py = heartFillBasePos[ix + 1];
        const r = Math.hypot(px, py);
        const invLen = 1 / Math.max(1e-6, r);
        heartFillDir[i * 2 + 0] = px * invLen;
        heartFillDir[i * 2 + 1] = py * invLen;

        const rNorm = fillMaxR > 0 ? Math.min(1, r / fillMaxR) : 0;
        heartFillAmp[i] = Math.pow(rNorm, 1.8) * (0.35 + 0.65 * Math.random());
      }

      // Glow layer (soft sprite; additive; vertexColors stay pink)
      const heartGlowMat = new THREE.PointsMaterial({
        map: glowTex,
        transparent: true,
        opacity: isMobile ? 0.16 : 0.18,
        alphaTest: 0.02,
        depthTest: false,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        size: isMobile ? 0.12 : 0.13,
        sizeAttenuation: true,
        vertexColors: true,
      });

      const heartGlow = new THREE.Points(heartFillGeo, heartGlowMat);
      heartGlow.frustumCulled = false;
      heartGlow.renderOrder = 5;
      heart.add(heartGlow);

      const heartFillMat = new THREE.PointsMaterial({
        map: dotTex,
        transparent: true,
        opacity: 0.78,
        alphaTest: 0.15,
        depthTest: false,
        depthWrite: false,
        blending: THREE.NormalBlending,
        size: isMobile ? 0.050 : 0.054,
        sizeAttenuation: true,
        vertexColors: true,
      });

      const heartFill = new THREE.Points(heartFillGeo, heartFillMat);
      heartFill.frustumCulled = false;
      heartFill.renderOrder = 10;
      heart.add(heartFill);

      // ---------- Layer B: heartEdge (outline + small jitter in/out) ----------
      const heartEdgeCount = COUNTS.heartEdge;
      const edgePointsRaw = heartShape.getSpacedPoints(heartEdgeCount);
      edgePointsRaw.pop();

      const edgePoints = edgePointsRaw.map((p) => new THREE.Vector2(p.x - outlineCenter.x, p.y - outlineCenter.y));

      const heartEdgeGeo = new THREE.BufferGeometry();
      const heartEdgePos = new Float32Array(edgePoints.length * 3);
      const heartEdgeCol = new Float32Array(edgePoints.length * 3);

      const edgeJitter = 0.26;
      const edgeZJitter = 0.04;

      const heartEdgeOutDir = new Float32Array(edgePoints.length * 2);

      for (let i = 0; i < edgePoints.length; i++) {
        const ix = i * 3;

        const prev = edgePoints[(i - 1 + edgePoints.length) % edgePoints.length];
        const curr = edgePoints[i];
        const next = edgePoints[(i + 1) % edgePoints.length];

        const tx = next.x - prev.x;
        const ty = next.y - prev.y;
        const invLen = 1 / Math.max(1e-6, Math.hypot(tx, ty));

        let nx = -ty * invLen;
        let ny = tx * invLen;

        if (nx * curr.x + ny * curr.y < 0) {
          nx = -nx;
          ny = -ny;
        }

        heartEdgeOutDir[i * 2 + 0] = nx;
        heartEdgeOutDir[i * 2 + 1] = ny;

        const j = (Math.random() - 0.5) * 2 * edgeJitter;

        heartEdgePos[ix + 0] = curr.x + nx * j;
        heartEdgePos[ix + 1] = curr.y + ny * j;
        heartEdgePos[ix + 2] = (Math.random() - 0.5) * edgeZJitter;

        writePinkColor(heartEdgeCol, ix, 0.62, 0.16);
      }

      const heartEdgePosAttr = new THREE.BufferAttribute(heartEdgePos, 3);
      heartEdgePosAttr.setUsage(THREE.DynamicDrawUsage);
      heartEdgeGeo.setAttribute("position", heartEdgePosAttr);
      heartEdgeGeo.setAttribute("color", new THREE.BufferAttribute(heartEdgeCol, 3));

      const heartEdgeBasePos = heartEdgePos.slice();
      const heartEdgeAmp = new Float32Array(edgePoints.length);

      for (let i = 0; i < edgePoints.length; i++) {
        heartEdgeAmp[i] = 0.20 + 0.80 * Math.pow(Math.random(), 1.25);
      }

      const heartEdgeMat = new THREE.PointsMaterial({
        map: dotTex,
        transparent: true,
        opacity: 0.68,
        alphaTest: 0.18,
        depthTest: false,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        size: isMobile ? 0.056 : 0.060,
        sizeAttenuation: true,
        vertexColors: true,
      });

      const heartEdge = new THREE.Points(heartEdgeGeo, heartEdgeMat);
      heartEdge.frustumCulled = false;
      heartEdge.renderOrder = 20;
      heart.add(heartEdge);

      // ---------- Layer C: outerDust (seed + random displacement; small more common) ----------
      const outerDustCount = COUNTS.outerDust;
      const outerDustGeo = new THREE.BufferGeometry();
      const outerDustPos = new Float32Array(outerDustCount * 3);
      const outerDustCol = new Float32Array(outerDustCount * 3);

      const dustMin = 0.55;
      const dustMax = isMobile ? 4.4 : 5.6;
      const dustPow = 2.2;
      const dustZJitter = 0.75;

      const pickFillChance = heartFillCount / (heartFillCount + edgePoints.length);

      for (let i = 0; i < outerDustCount; i++) {
        const ix = i * 3;

        const pickFill = Math.random() < pickFillChance;
        const baseArr = pickFill ? heartFillPos : heartEdgeBasePos;
        const baseCount = pickFill ? heartFillCount : edgePoints.length;
        const si = Math.floor(Math.random() * baseCount) * 3;

        const bx = baseArr[si + 0];
        const by = baseArr[si + 1];
        const bz = baseArr[si + 2];

        const a = Math.random() * Math.PI * 2;
        const zTilt = (Math.random() - 0.5) * 0.38;

        const dx = Math.cos(a) * Math.cos(zTilt);
        const dy = Math.sin(a) * Math.cos(zTilt);
        const dz = Math.sin(zTilt);

        const r = dustMin + (dustMax - dustMin) * Math.pow(Math.random(), dustPow);
        const jitter = (Math.random() - 0.5) * 0.22;

        outerDustPos[ix + 0] = bx + dx * (r + jitter);
        outerDustPos[ix + 1] = by + dy * (r + jitter);
        outerDustPos[ix + 2] = bz + dz * (r * 0.42) + (Math.random() - 0.5) * dustZJitter;

        writePinkColor(outerDustCol, ix, 0.46, 0.22);
      }

      const outerDustPosAttr = new THREE.BufferAttribute(outerDustPos, 3);
      outerDustPosAttr.setUsage(THREE.DynamicDrawUsage);
      outerDustGeo.setAttribute("position", outerDustPosAttr);
      outerDustGeo.setAttribute("color", new THREE.BufferAttribute(outerDustCol, 3));

      const outerDustBasePos = outerDustPos.slice();
      const outerDustDir = new Float32Array(outerDustCount * 2);
      const outerDustAmp = new Float32Array(outerDustCount);

      for (let i = 0; i < outerDustCount; i++) {
        const ix = i * 3;
        const px = outerDustBasePos[ix + 0];
        const py = outerDustBasePos[ix + 1];
        const invLen = 1 / Math.max(1e-6, Math.hypot(px, py));
        outerDustDir[i * 2 + 0] = px * invLen;
        outerDustDir[i * 2 + 1] = py * invLen;
        outerDustAmp[i] = 0.25 + 0.75 * Math.pow(Math.random(), 0.70);
      }

      const outerDustMat = new THREE.PointsMaterial({
        map: glowTex,
        transparent: true,
        opacity: isMobile ? 0.12 : 0.14,
        alphaTest: 0.03,
        depthTest: false,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        size: isMobile ? 0.052 : 0.055,
        sizeAttenuation: true,
        vertexColors: true,
      });

      const outerDust = new THREE.Points(outerDustGeo, outerDustMat);
      outerDust.frustumCulled = false;
      outerDust.renderOrder = 1;
      heart.add(outerDust);

      // ---------- Layer D: sparkle/glint (edge-only; animated color) ----------
      const sparkleCount = isMobile ? 300 : 600;
      const sparkleGeo = new THREE.BufferGeometry();
      const sparklePos = new Float32Array(sparkleCount * 3);
      const sparkleCol = new Float32Array(sparkleCount * 3);
      const sparkleTint = new Float32Array(sparkleCount * 3);
      const sparklePhase = new Float32Array(sparkleCount);
      const sparkleSpeed = new Float32Array(sparkleCount);

      for (let i = 0; i < sparkleCount; i++) {
        const ix = i * 3;

        const si = Math.floor(Math.random() * edgePoints.length) * 3;
        const bx = heartEdgeBasePos[si + 0];
        const by = heartEdgeBasePos[si + 1];
        const bz = heartEdgeBasePos[si + 2];

        const a = Math.random() * Math.PI * 2;
        const zTilt = (Math.random() - 0.5) * 0.9;

        const dx = Math.cos(a) * Math.cos(zTilt);
        const dy = Math.sin(a) * Math.cos(zTilt);
        const dz = Math.sin(zTilt);

        const r = 0.10 + Math.random() * 0.46;
        const jitter = (Math.random() - 0.5) * 0.10;

        sparklePos[ix + 0] = bx + dx * (r + jitter);
        sparklePos[ix + 1] = by + dy * (r + jitter);
        sparklePos[ix + 2] = bz + dz * (r * 0.28);

        const hue = THREE.MathUtils.degToRad(332 + (Math.random() - 0.5) * 10);
        const h = (hue / (Math.PI * 2) + 1) % 1;
        _c.setHSL(h, 0.35 + Math.random() * 0.25, 0.78 + Math.random() * 0.20, THREE.SRGBColorSpace);

        sparkleTint[ix + 0] = _c.r;
        sparkleTint[ix + 1] = _c.g;
        sparkleTint[ix + 2] = _c.b;

        sparkleCol[ix + 0] = 0;
        sparkleCol[ix + 1] = 0;
        sparkleCol[ix + 2] = 0;

        sparklePhase[i] = Math.random() * Math.PI * 2;
        sparkleSpeed[i] = 8 + Math.random() * 10;
      }

      const sparklePosAttr = new THREE.BufferAttribute(sparklePos, 3);
      sparklePosAttr.setUsage(THREE.DynamicDrawUsage);
      sparkleGeo.setAttribute("position", sparklePosAttr);

      const sparkleColAttr = new THREE.BufferAttribute(sparkleCol, 3);
      sparkleColAttr.setUsage(THREE.DynamicDrawUsage);
      sparkleGeo.setAttribute("color", sparkleColAttr);

      const sparkleBasePos = sparklePos.slice();
      const sparkleDir = new Float32Array(sparkleCount * 2);
      const sparkleAmp = new Float32Array(sparkleCount);

      for (let i = 0; i < sparkleCount; i++) {
        const ix = i * 3;
        const px = sparkleBasePos[ix + 0];
        const py = sparkleBasePos[ix + 1];
        const invLen = 1 / Math.max(1e-6, Math.hypot(px, py));
        sparkleDir[i * 2 + 0] = px * invLen;
        sparkleDir[i * 2 + 1] = py * invLen;
        sparkleAmp[i] = 0.20 + 0.80 * Math.pow(Math.random(), 1.10);
      }

      const sparkleMat = new THREE.PointsMaterial({
        map: dotTex,
        transparent: true,
        opacity: 0.92,
        alphaTest: 0.58,
        depthTest: false,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        size: isMobile ? 0.066 : 0.072,
        sizeAttenuation: true,
        vertexColors: true,
      });

      const sparkle = new THREE.Points(sparkleGeo, sparkleMat);
      sparkle.frustumCulled = false;
      sparkle.renderOrder = 30;
      heart.add(sparkle);

      // ---------- Heartbeat outward offsets ----------
      const OUTWARD_MAX = {
        outerDust: isMobile ? 0.9 : 1.15,
        fill: isMobile ? 2.0 : 2.8,
        edge: 0.6,
        sparkle: 0.35,
      };

      // ---------- Animation ----------
      const clock = new THREE.Clock();

      function heartbeatScale(t) {
        const speed = 3.2;
        const b1 = Math.pow(Math.max(0, Math.sin(t * speed)), 6);
        const b2 = Math.pow(Math.max(0, Math.sin(t * speed + 1.1)), 10);
        const relax = Math.pow(Math.max(0, Math.sin(t * speed + Math.PI * 0.75)), 2);
        return 1 + 0.11 * (b1 + 0.6 * b2) - 0.045 * relax;
      }

      let didMarkOk = false;

      function animate() {
        requestAnimationFrame(animate);

        if (!didMarkOk) {
          didMarkOk = true;
          window.__HEART_OK__ = true;
          hideOverlay();
        }

        const t = clock.getElapsedTime();

        // 心跳：中心固定，粒子向外擴散（不使用 group scale 做 pulse）
        const pulse = heartbeatScale(t);
        const pulseBoost = 1 + (pulse - 1) * 1.6;
        const kick = THREE.MathUtils.clamp((pulseBoost - 1) / 0.12, 0, 1);
        const outward = kick;

        for (let i = 0; i < heartFillCount; i++) {
          const ix = i * 3;
          const dx = heartFillDir[i * 2 + 0];
          const dy = heartFillDir[i * 2 + 1];
          const amp = heartFillAmp[i] * OUTWARD_MAX.fill * outward;
          heartFillPos[ix + 0] = heartFillBasePos[ix + 0] + dx * amp;
          heartFillPos[ix + 1] = heartFillBasePos[ix + 1] + dy * amp;
          heartFillPos[ix + 2] = heartFillBasePos[ix + 2];
        }
        heartFillGeo.attributes.position.needsUpdate = true;

        for (let i = 0; i < outerDustCount; i++) {
          const ix = i * 3;
          const dx = outerDustDir[i * 2 + 0];
          const dy = outerDustDir[i * 2 + 1];
          const amp = outerDustAmp[i] * OUTWARD_MAX.outerDust * outward;
          outerDustPos[ix + 0] = outerDustBasePos[ix + 0] + dx * amp;
          outerDustPos[ix + 1] = outerDustBasePos[ix + 1] + dy * amp;
          outerDustPos[ix + 2] = outerDustBasePos[ix + 2];
        }
        outerDustGeo.attributes.position.needsUpdate = true;

        for (let i = 0; i < edgePoints.length; i++) {
          const ix = i * 3;
          const dx = heartEdgeOutDir[i * 2 + 0];
          const dy = heartEdgeOutDir[i * 2 + 1];
          const amp = heartEdgeAmp[i] * OUTWARD_MAX.edge * outward;
          heartEdgePos[ix + 0] = heartEdgeBasePos[ix + 0] + dx * amp;
          heartEdgePos[ix + 1] = heartEdgeBasePos[ix + 1] + dy * amp;
          heartEdgePos[ix + 2] = heartEdgeBasePos[ix + 2];
        }
        heartEdgeGeo.attributes.position.needsUpdate = true;

        for (let i = 0; i < sparkleCount; i++) {
          const ix = i * 3;
          const dx = sparkleDir[i * 2 + 0];
          const dy = sparkleDir[i * 2 + 1];
          const amp = sparkleAmp[i] * OUTWARD_MAX.sparkle * outward;
          sparklePos[ix + 0] = sparkleBasePos[ix + 0] + dx * amp;
          sparklePos[ix + 1] = sparkleBasePos[ix + 1] + dy * amp;
          sparklePos[ix + 2] = sparkleBasePos[ix + 2];
        }
        sparkleGeo.attributes.position.needsUpdate = true;

        const breath = 0.03 * Math.sin(t * 0.9);
        bloomPass.strength = BLOOM.strength * THREE.MathUtils.clamp(0.86 + 0.20 * kick + breath, 0.76, 1.02);

        for (let i = 0; i < sparkleCount; i++) {
          const ix = i * 3;
          const blink = Math.pow(Math.max(0, Math.sin(t * sparkleSpeed[i] + sparklePhase[i])), 18);
          const intensity = 0.02 + blink * 3.9;
          sparkleCol[ix + 0] = sparkleTint[ix + 0] * intensity;
          sparkleCol[ix + 1] = sparkleTint[ix + 1] * intensity;
          sparkleCol[ix + 2] = sparkleTint[ix + 2] * intensity;
        }
        sparkleGeo.attributes.color.needsUpdate = true;

        composer.render();
      }

      animate();

      // ---------- Resize ----------
      window.addEventListener("resize", () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const dpr = Math.min(window.devicePixelRatio || 1, dprCap);

        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        camera.lookAt(0, 0, 0);

        renderer.setPixelRatio(dpr);
        renderer.setSize(w, h);

        composer.setPixelRatio(dpr);
        composer.setSize(w, h);
        bloomPass.setSize(w, h);
      }, { passive: true });
    })().catch((err) => {
      showOverlayError(window.__HEART_CDNS_TRIED__ || []);
      appendOverlayErrorMessage(err);
      console.error(err);
    });
  </script>
</body>
</html>
