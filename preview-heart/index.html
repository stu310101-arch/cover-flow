<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>3D 跳動發光愛心</title>
  <style>
    :root { color-scheme: dark; }

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
    }

    body {
      overflow: hidden;
      background: #020612;
      font-family: system-ui, -apple-system, "Segoe UI", "Noto Sans TC", sans-serif;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      display: block;
      background: transparent;
    }

    #overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: grid;
      place-items: center;
      background: #020612;
      color: rgba(255,255,255,0.92);
    }

    #overlay.hide {
      opacity: 0;
      transition: opacity 300ms ease;
      pointer-events: none;
    }

    #overlay .box {
      padding: 14px 16px;
      border-radius: 14px;
      background: rgba(2, 8, 20, 0.45);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      text-align: center;
      max-width: min(520px, calc(100vw - 28px));
      line-height: 1.5;
    }

    #overlay .title {
      font-size: 15px;
      font-weight: 650;
      letter-spacing: 0.2px;
    }

    #overlay .desc {
      margin-top: 6px;
      font-size: 12px;
      color: rgba(255,255,255,0.72);
      white-space: pre-line;
    }

    /* 避免選取拖曳 */
    * { -webkit-user-select: none; user-select: none; }
  </style>

  <!--
    Module 版本（不依賴 importmap）：
    - 直接用 esm.sh 匯入 three 與 examples/jsm addons
    - iOS Safari/Chrome 對 importmap 支援不完整時，也能正常載入
  -->
</head>
<body>
  <div id="overlay" role="status" aria-live="polite">
    <div class="box">
      <div class="title">載入中…</div>
      <div class="desc">正在載入 3D 模組</div>
    </div>
  </div>

  <script>
    (function () {
      const overlay = document.getElementById("overlay");
      if (!overlay) return;

      window.setTimeout(() => {
        if (window.__HEART_OK__ || window.__HEART_FAILED__) return;

        const tried = Array.isArray(window.__HEART_CDNS_TRIED__) && window.__HEART_CDNS_TRIED__.length
          ? window.__HEART_CDNS_TRIED__
          : ["esm.sh", "jsdelivr"];

        const titleEl = overlay.querySelector(".title");
        const descEl = overlay.querySelector(".desc");
        if (titleEl) titleEl.textContent = "3D 模組載入逾時";
        if (descEl) descEl.textContent = `3D 模組載入逾時：仍無法連線到 CDN（${tried.join("、")}）。請確認網路環境或稍後再試。`;
      }, 15000);
    })();
  </script>

  <script type="module">
    const overlayEl = document.getElementById("overlay");

    function setOverlayText(title, desc) {
      if (!overlayEl) return;
      const titleEl = overlayEl.querySelector(".title");
      const descEl = overlayEl.querySelector(".desc");
      if (titleEl) titleEl.textContent = title;
      if (descEl) descEl.textContent = desc;
    }

    function showOverlayError(triedNames) {
      window.__HEART_FAILED__ = true;
      const triedText = (Array.isArray(triedNames) && triedNames.length)
        ? triedNames.join("、")
        : "esm.sh、jsdelivr";

      setOverlayText(
        "3D 模組載入失敗",
        `3D 模組載入失敗：無法載入 CDN（${triedText}）。請確認網路環境或稍後再試。`
      );
    }

    function appendOverlayErrorMessage(err) {
      if (!overlayEl) return;
      const descEl = overlayEl.querySelector(".desc");
      if (!descEl) return;

      const msg = err && err.message ? String(err.message) : "";
      if (!msg) return;

      const shortMsg = msg.length > 160 ? `${msg.slice(0, 160)}…` : msg;
      descEl.textContent += `\n錯誤：${shortMsg}`;
    }

    const CDN_FALLBACKS = [
      {
        name: "esm.sh",
        three: "https://esm.sh/three@0.182.0",
      },
      {
        name: "jsdelivr",
        three: "https://cdn.jsdelivr.net/npm/three@0.182.0/+esm",
      },
    ];

    async function importWithTimeout(url, timeoutMs) {
      const p = import(url);
      p.catch(() => {});

      let timeoutId;
      const timeoutPromise = new Promise((_, reject) => {
        timeoutId = window.setTimeout(() => reject(new Error(`Timeout while importing: ${url}`)), timeoutMs);
      });

      const result = await Promise.race([p, timeoutPromise]);
      window.clearTimeout(timeoutId);
      return result;
    }

    async function loadThreeModules() {
      const tried = [];
      window.__HEART_CDNS_TRIED__ = tried;

      const timeoutMs = 5500;

      for (const cdn of CDN_FALLBACKS) {
        tried.push(cdn.name);
        setOverlayText("載入中…", `正在嘗試載入 3D 模組（${cdn.name}）`);

        try {
          const THREE = await importWithTimeout(cdn.three, timeoutMs);
          return { THREE };
        } catch (err) {
          console.warn(`[heart-3d] CDN 失敗：${cdn.name}`, err);
        }
      }

      showOverlayError(tried);
      throw new Error(`Failed to load three modules from: ${tried.join(", ")}`);
    }

    (async () => {
      const { THREE } = await loadThreeModules();

      function hideOverlay() {
        if (!overlayEl) return;
        overlayEl.classList.add("hide");
        window.setTimeout(() => overlayEl.remove(), 380);
      }

      const isMobile = matchMedia("(max-width: 768px)").matches;
      const dprCap = isMobile ? 1.5 : 2;

      const COUNTS = {
        heartFill: isMobile ? 11000 : 20000,
        heartEdge: isMobile ? 2400 : 4200,
        outerDust: isMobile ? 7000 : 14000,
      };

      // ---------- Renderer / Scene / Camera ----------
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020612);

      const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 200);
      camera.position.set(0, 0.55, 4.6);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, dprCap));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.18;
      renderer.setClearColor(0x020612, 1);
      document.body.appendChild(renderer.domElement);

      // ---------- Sprite (hard dot; no halo ring) ----------
      function makeDotTexture({ size = 64 } = {}) {
        const c = document.createElement("canvas");
        c.width = c.height = size;

        const ctx = c.getContext("2d");
        ctx.clearRect(0, 0, size, size);
        ctx.fillStyle = "rgba(255,255,255,1)";
        ctx.beginPath();
        ctx.arc(size * 0.5, size * 0.5, size * 0.46, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();

        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.generateMipmaps = false;
        tex.needsUpdate = true;
        return tex;
      }

      const dotTex = makeDotTexture({ size: 64 });

      // ---------- Heart (2D shape) ----------
      const heartShape = new THREE.Shape();
      const x = 0, y = 0;

      heartShape.moveTo(x + 5, y + 5);
      heartShape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
      heartShape.bezierCurveTo(x - 6, y, x - 6, y + 7, x - 6, y + 7);
      heartShape.bezierCurveTo(x - 6, y + 11, x - 3, y + 15, x + 5, y + 19);
      heartShape.bezierCurveTo(x + 12, y + 15, x + 16, y + 11, x + 16, y + 7);
      heartShape.bezierCurveTo(x + 16, y + 7, x + 16, y, x + 10, y);
      heartShape.bezierCurveTo(x + 7, y, x + 5, y + 5, x + 5, y + 5);

      const outlinePolyRaw = heartShape.getSpacedPoints(520);
      outlinePolyRaw.pop();
      const outlinePoly = outlinePolyRaw.map((p) => new THREE.Vector2(p.x, p.y));

      const outlineBoxRaw = new THREE.Box2().setFromPoints(outlinePoly);
      const outlineCenter = outlineBoxRaw.getCenter(new THREE.Vector2());

      for (let i = 0; i < outlinePoly.length; i++) {
        outlinePoly[i].sub(outlineCenter);
      }

      const outlineBox = new THREE.Box2().setFromPoints(outlinePoly);

      function isPointInPolygon(p, poly) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i].x, yi = poly[i].y;
          const xj = poly[j].x, yj = poly[j].y;
          const intersect = ((yi > p.y) !== (yj > p.y))
            && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      const MAX_TRIES_IN_POLY = 900;
      const _v2 = new THREE.Vector2();

      function sampleInHeart2D(out) {
        for (let tries = 0; tries < MAX_TRIES_IN_POLY; tries++) {
          out.set(
            THREE.MathUtils.lerp(outlineBox.min.x, outlineBox.max.x, Math.random()),
            THREE.MathUtils.lerp(outlineBox.min.y, outlineBox.max.y, Math.random())
          );
          if (isPointInPolygon(out, outlinePoly)) return out;
        }

        out.set(0, 0);
        return out;
      }

      const heart = new THREE.Group();
      heart.rotation.set(0, 0, Math.PI);
      scene.add(heart);

      const baseScale = 0.12;
      heart.scale.setScalar(baseScale);

      // ---------- Colors (pink / magenta only; tiny hue jitter) ----------
      const _c = new THREE.Color();
      function writePinkColor(dst, ix, lightnessBase, lightnessJitter) {
        const hue = THREE.MathUtils.degToRad(330 + (Math.random() - 0.5) * 16);
        const h = (hue / (Math.PI * 2) + 1) % 1;
        const s = 0.86 + Math.random() * 0.12;
        const l = THREE.MathUtils.clamp(lightnessBase + (Math.random() - 0.5) * lightnessJitter, 0.32, 0.76);
        _c.setHSL(h, s, l, THREE.SRGBColorSpace);
        dst[ix + 0] = _c.r;
        dst[ix + 1] = _c.g;
        dst[ix + 2] = _c.b;
      }

      // ---------- Layer A: heartFill (almost 2D) ----------
      const heartFillCount = COUNTS.heartFill;
      const heartFillGeo = new THREE.BufferGeometry();
      const heartFillPos = new Float32Array(heartFillCount * 3);
      const heartFillCol = new Float32Array(heartFillCount * 3);

      const fillZJitter = 0.06;

      for (let i = 0; i < heartFillCount; i++) {
        const ix = i * 3;
        sampleInHeart2D(_v2);

        heartFillPos[ix + 0] = _v2.x;
        heartFillPos[ix + 1] = _v2.y;
        heartFillPos[ix + 2] = (Math.random() - 0.5) * fillZJitter;

        writePinkColor(heartFillCol, ix, 0.58, 0.18);
      }

      heartFillGeo.setAttribute("position", new THREE.BufferAttribute(heartFillPos, 3));
      heartFillGeo.setAttribute("color", new THREE.BufferAttribute(heartFillCol, 3));

      const heartFillMat = new THREE.PointsMaterial({
        map: dotTex,
        transparent: true,
        opacity: 0.78,
        alphaTest: 0.70,
        depthTest: false,
        depthWrite: false,
        blending: THREE.NormalBlending,
        size: isMobile ? 0.050 : 0.054,
        sizeAttenuation: true,
        vertexColors: true,
      });

      const heartFill = new THREE.Points(heartFillGeo, heartFillMat);
      heartFill.frustumCulled = false;
      heartFill.renderOrder = 10;
      heart.add(heartFill);

      // ---------- Layer B: heartEdge (outline + small jitter in/out) ----------
      const heartEdgeCount = COUNTS.heartEdge;
      const edgePointsRaw = heartShape.getSpacedPoints(heartEdgeCount);
      edgePointsRaw.pop();

      const edgePoints = edgePointsRaw.map((p) => new THREE.Vector2(p.x - outlineCenter.x, p.y - outlineCenter.y));

      const heartEdgeGeo = new THREE.BufferGeometry();
      const heartEdgePos = new Float32Array(edgePoints.length * 3);
      const heartEdgeCol = new Float32Array(edgePoints.length * 3);

      const edgeJitter = 0.26;
      const edgeZJitter = 0.04;

      for (let i = 0; i < edgePoints.length; i++) {
        const ix = i * 3;

        const prev = edgePoints[(i - 1 + edgePoints.length) % edgePoints.length];
        const curr = edgePoints[i];
        const next = edgePoints[(i + 1) % edgePoints.length];

        const tx = next.x - prev.x;
        const ty = next.y - prev.y;
        const invLen = 1 / Math.max(1e-6, Math.hypot(tx, ty));

        const nx = -ty * invLen;
        const ny = tx * invLen;

        const j = (Math.random() - 0.5) * 2 * edgeJitter;

        heartEdgePos[ix + 0] = curr.x + nx * j;
        heartEdgePos[ix + 1] = curr.y + ny * j;
        heartEdgePos[ix + 2] = (Math.random() - 0.5) * edgeZJitter;

        writePinkColor(heartEdgeCol, ix, 0.62, 0.16);
      }

      heartEdgeGeo.setAttribute("position", new THREE.BufferAttribute(heartEdgePos, 3));
      heartEdgeGeo.setAttribute("color", new THREE.BufferAttribute(heartEdgeCol, 3));

      const heartEdgeMat = new THREE.PointsMaterial({
        map: dotTex,
        transparent: true,
        opacity: 0.68,
        alphaTest: 0.70,
        depthTest: false,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        size: isMobile ? 0.056 : 0.060,
        sizeAttenuation: true,
        vertexColors: true,
      });

      const heartEdge = new THREE.Points(heartEdgeGeo, heartEdgeMat);
      heartEdge.frustumCulled = false;
      heartEdge.renderOrder = 20;
      heart.add(heartEdge);

      // ---------- Layer C: outerDust (seed + random displacement; small more common) ----------
      const outerDustCount = COUNTS.outerDust;
      const outerDustGeo = new THREE.BufferGeometry();
      const outerDustPos = new Float32Array(outerDustCount * 3);
      const outerDustCol = new Float32Array(outerDustCount * 3);

      const dustMin = 0.55;
      const dustMax = 5.6;
      const dustPow = 2.2;
      const dustZJitter = 0.75;

      const pickFillChance = heartFillCount / (heartFillCount + edgePoints.length);

      for (let i = 0; i < outerDustCount; i++) {
        const ix = i * 3;

        const pickFill = Math.random() < pickFillChance;
        const baseArr = pickFill ? heartFillPos : heartEdgePos;
        const baseCount = pickFill ? heartFillCount : edgePoints.length;
        const si = Math.floor(Math.random() * baseCount) * 3;

        const bx = baseArr[si + 0];
        const by = baseArr[si + 1];
        const bz = baseArr[si + 2];

        const a = Math.random() * Math.PI * 2;
        const zTilt = (Math.random() - 0.5) * 0.38;

        const dx = Math.cos(a) * Math.cos(zTilt);
        const dy = Math.sin(a) * Math.cos(zTilt);
        const dz = Math.sin(zTilt);

        const r = dustMin + (dustMax - dustMin) * Math.pow(Math.random(), dustPow);
        const jitter = (Math.random() - 0.5) * 0.22;

        outerDustPos[ix + 0] = bx + dx * (r + jitter);
        outerDustPos[ix + 1] = by + dy * (r + jitter);
        outerDustPos[ix + 2] = bz + dz * (r * 0.42) + (Math.random() - 0.5) * dustZJitter;

        writePinkColor(outerDustCol, ix, 0.46, 0.22);
      }

      outerDustGeo.setAttribute("position", new THREE.BufferAttribute(outerDustPos, 3));
      outerDustGeo.setAttribute("color", new THREE.BufferAttribute(outerDustCol, 3));

      const outerDustMat = new THREE.PointsMaterial({
        map: dotTex,
        transparent: true,
        opacity: 0.15,
        alphaTest: 0.62,
        depthTest: false,
        depthWrite: false,
        blending: THREE.NormalBlending,
        size: isMobile ? 0.040 : 0.042,
        sizeAttenuation: true,
        vertexColors: true,
      });

      const outerDust = new THREE.Points(outerDustGeo, outerDustMat);
      outerDust.frustumCulled = false;
      outerDust.renderOrder = 1;
      heart.add(outerDust);

      // ---------- Animation ----------
      const clock = new THREE.Clock();

      function heartbeatScale(t) {
        const speed = 3.2;
        const b1 = Math.pow(Math.max(0, Math.sin(t * speed)), 6);
        const b2 = Math.pow(Math.max(0, Math.sin(t * speed + 1.1)), 10);
        const relax = Math.pow(Math.max(0, Math.sin(t * speed + Math.PI * 0.75)), 2);
        return 1 + 0.11 * (b1 + 0.6 * b2) - 0.045 * relax;
      }

      let didMarkOk = false;

      function animate() {
        requestAnimationFrame(animate);

        if (!didMarkOk) {
          didMarkOk = true;
          window.__HEART_OK__ = true;
          hideOverlay();
        }

        const t = clock.elapsedTime;

        // 愛心心跳（僅縮放，不旋轉）
        const pulse = heartbeatScale(t);
        heart.scale.setScalar(baseScale * pulse);

        renderer.render(scene, camera);
      }

      animate();

      // ---------- Resize ----------
      window.addEventListener("resize", () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const dpr = Math.min(window.devicePixelRatio || 1, dprCap);

        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        camera.lookAt(0, 0, 0);

        renderer.setPixelRatio(dpr);
        renderer.setSize(w, h);
      }, { passive: true });
    })().catch((err) => {
      showOverlayError(window.__HEART_CDNS_TRIED__ || []);
      appendOverlayErrorMessage(err);
      console.error(err);
    });
  </script>
</body>
</html>
