<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>3D 跳動發光愛心</title>
  <style>
    :root { color-scheme: dark; }

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
    }

    body {
      overflow: hidden;
      /* 背景：深藍→內部淺藍 radial-gradient */
      background: radial-gradient(circle at 50% 35%, #5cc6ff 0%, #1a4f9b 35%, #07183a 65%, #020612 100%);
      font-family: system-ui, -apple-system, "Segoe UI", "Noto Sans TC", sans-serif;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      display: block;
      background: transparent;
    }

    #hint {
      position: fixed;
      left: 12px;
      bottom: 12px;
      z-index: 10;
      font-size: 12px;
      line-height: 1.35;
      color: rgba(255,255,255,0.75);
      background: rgba(2, 8, 20, 0.35);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 8px 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      max-width: min(520px, calc(100vw - 24px));
    }

    /* 避免選取拖曳 */
    * { -webkit-user-select: none; user-select: none; }
  </style>

  <!--
    重要：three 的 examples/jsm addons 內部會用 `from 'three'` 這種 bare specifier。
    若沒有 importmap，瀏覽器會無法解析，導致你看到「只有背景、沒有愛心」。
  -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="hint">
    若你只看到背景沒有愛心：
    <br>1) 請用本機/網路伺服器開啟（例如 <code>python -m http.server</code>），不要用 <code>file://</code>
    <br>2) iPhone/iPad 需 iOS Safari 16.4+ 才支援 importmap（Chrome(iOS) 也同樣受限）
  </div>
  <script>
    (function () {
      const hint = document.getElementById("hint");
      if (!hint) return;

      const supportsModule = "noModule" in document.createElement("script");
      if (!supportsModule) {
        hint.textContent = "此頁需要支援 ES Modules 的瀏覽器。";
        return;
      }

      if (window.HTMLScriptElement && typeof HTMLScriptElement.supports === "function") {
        const ok = HTMLScriptElement.supports("importmap");
        if (!ok) {
          hint.innerHTML =
            "此頁需要 Import Maps（iPhone/iPad 需 iOS Safari 16.4+）。" +
            "<br>另外請用本機/網路伺服器（http/https）開啟，不要用 <code>file://</code>。";
        }
      }
    })();
  </script>

  <script type="module">
    import * as THREE from "three";
    import { MeshSurfaceSampler } from "three/addons/math/MeshSurfaceSampler.js";
    import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";

    const isMobile = matchMedia("(max-width: 768px)").matches;
    const dprCap = isMobile ? 1.5 : 2;

    // ---------- Renderer / Scene / Camera ----------
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 0.55, 4.6);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, dprCap));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    // 透明清除，讓 body 的 radial-gradient 背景可透出
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    // ---------- Environment (IBL) ----------
    const environment = new RoomEnvironment();
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    scene.environment = pmremGenerator.fromScene(environment, 0.04).texture;
    environment.dispose();
    pmremGenerator.dispose();

    // ---------- Postprocessing (Bloom) ----------
    const composer = new EffectComposer(renderer);
    composer.setPixelRatio(Math.min(window.devicePixelRatio || 1, dprCap));
    composer.setSize(window.innerWidth, window.innerHeight);

    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.50,  // strength（降低避免洗白）
      0.34,  // radius
      0.92   // threshold（提高以保留紅色）
    );

    composer.addPass(renderPass);
    composer.addPass(bloomPass);
    composer.addPass(new OutputPass());

    // ---------- Lights ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.33));

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
    keyLight.position.set(3, 4, 5);
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0x9fd6ff, 0.40);
    fillLight.position.set(-4, -1, 3);
    scene.add(fillLight);

    const rimLight = new THREE.DirectionalLight(0xff99aa, 0.75);
    rimLight.position.set(-4, 2, -4);
    scene.add(rimLight);

    // ---------- 3D Heart ----------
    const heartShape = new THREE.Shape();
    const x = 0, y = 0;

    heartShape.moveTo(x + 5, y + 5);
    heartShape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
    heartShape.bezierCurveTo(x - 6, y, x - 6, y + 7, x - 6, y + 7);
    heartShape.bezierCurveTo(x - 6, y + 11, x - 3, y + 15, x + 5, y + 19);
    heartShape.bezierCurveTo(x + 12, y + 15, x + 16, y + 11, x + 16, y + 7);
    heartShape.bezierCurveTo(x + 16, y + 7, x + 16, y, x + 10, y);
    heartShape.bezierCurveTo(x + 7, y, x + 5, y + 5, x + 5, y + 5);

    const heartGeo = new THREE.ExtrudeGeometry(heartShape, {
      depth: 4,
      steps: 2,
      bevelEnabled: true,
      bevelThickness: 1.7,
      bevelSize: 1.25,
      bevelOffset: 0,
      bevelSegments: 6,
    });
    heartGeo.center();
    heartGeo.computeBoundingSphere();
    const heartRadius = heartGeo.boundingSphere ? heartGeo.boundingSphere.radius : 1;

    // 整顆心只用粒子呈現（Mesh 只用來表面取樣，且保持 invisible）
    const heart = new THREE.Group();
    // 尖端朝下：避免用 Z 軸 180 度翻轉（會把愛心上下顛倒）
    heart.rotation.set(0.18, 0, 0);
    scene.add(heart);

    const baseScale = 0.12;
    heart.scale.setScalar(baseScale);

    // ---------- Glowy Particles ----------
    function makeRadialGlowTexture({
      size = 128,
      innerColor = "rgba(255,255,255,1)",
      midColor = "rgba(255,255,255,0.25)",
      outerColor = "rgba(255,255,255,0)",
    } = {}) {
      const c = document.createElement("canvas");
      c.width = c.height = size;
      const gctx = c.getContext("2d");
      const g = gctx.createRadialGradient(size * 0.5, size * 0.5, 0, size * 0.5, size * 0.5, size * 0.5);
      g.addColorStop(0.0, innerColor);
      g.addColorStop(0.35, midColor);
      g.addColorStop(1.0, outerColor);
      gctx.fillStyle = g;
      gctx.fillRect(0, 0, size, size);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearMipmapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.needsUpdate = true;
      return tex;
    }

    const blueSprite = makeRadialGlowTexture({
      innerColor: "rgba(215,250,255,1)",
      midColor: "rgba(140,225,255,0.18)",
      outerColor: "rgba(140,225,255,0)",
    });

    const whiteSprite = makeRadialGlowTexture({
      innerColor: "rgba(255,255,255,1)",
      midColor: "rgba(255,255,255,0.14)",
      outerColor: "rgba(255,255,255,0)",
    });

    // 1) 全場景淡藍粒子（保留，但固定在愛心後方，避免蓋住愛心）
    const ambientCount = isMobile ? 650 : 1200;
    const ambientBox = new THREE.Vector3(42, 26, 42);
    const half = ambientBox.clone().multiplyScalar(0.5);

    const ambientZMin = -half.z;
    const ambientZMax = -0.6;

    const ambientGeo = new THREE.BufferGeometry();
    const ambientPos = new Float32Array(ambientCount * 3);
    const ambientVel = new Float32Array(ambientCount * 3);
    const ambientCol = new Float32Array(ambientCount * 3);

    for (let i = 0; i < ambientCount; i++) {
      const ix = i * 3;
      ambientPos[ix + 0] = (Math.random() - 0.5) * ambientBox.x;
      ambientPos[ix + 1] = (Math.random() - 0.5) * ambientBox.y;
      ambientPos[ix + 2] = THREE.MathUtils.lerp(ambientZMin, ambientZMax, Math.random());

      ambientVel[ix + 0] = (Math.random() - 0.5) * 0.10;
      ambientVel[ix + 1] = (Math.random() * 0.6 + 0.4) * 0.16;
      ambientVel[ix + 2] = (Math.random() - 0.5) * 0.10;

      const c = new THREE.Color(0x7fe6ff);
      const tint = 0.16 + Math.random() * 0.22;
      ambientCol[ix + 0] = c.r * tint;
      ambientCol[ix + 1] = c.g * tint;
      ambientCol[ix + 2] = c.b * tint;
    }

    ambientGeo.setAttribute("position", new THREE.BufferAttribute(ambientPos, 3));
    ambientGeo.setAttribute("color", new THREE.BufferAttribute(ambientCol, 3));

    const ambientMat = new THREE.PointsMaterial({
      map: blueSprite,
      transparent: true,
      opacity: 0.08,
      alphaTest: 0.02,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      size: 0.060,
      sizeAttenuation: true,
      vertexColors: true,
    });

    const ambientPoints = new THREE.Points(ambientGeo, ambientMat);
    ambientPoints.renderOrder = -20;
    scene.add(ambientPoints);

    // 2) 愛心粒子：高密度表面粒子 + 外層白色 halo（沿法線外擴）
    const samplerMesh = new THREE.Mesh(heartGeo, new THREE.MeshBasicMaterial());
    samplerMesh.visible = false;
    const sampler = new MeshSurfaceSampler(samplerMesh).build();

    const _p = new THREE.Vector3();
    const _n = new THREE.Vector3();
    const heartPink = new THREE.Color(0xff1e2d);
    const haloWhite = new THREE.Color(0xffffff);
    const _col = new THREE.Color();

    // 2-1) 主體：高密度「表面」粒子（不再把表面點往中心縮放，避免凹形愛心輪廓被破壞）
    const surfaceCount = isMobile ? 9500 : 18500;
    const surfaceThickness = 0.18;

    const surfaceGeo = new THREE.BufferGeometry();
    const surfacePos = new Float32Array(surfaceCount * 3);
    const surfaceBase = new Float32Array(surfaceCount * 3);
    const surfaceNrm = new Float32Array(surfaceCount * 3);
    const surfacePhase = new Float32Array(surfaceCount);
    const surfaceCol = new Float32Array(surfaceCount * 3);

    for (let i = 0; i < surfaceCount; i++) {
      const ix = i * 3;
      sampler.sample(_p, _n);

      _p.addScaledVector(_n, (Math.random() - 0.5) * surfaceThickness);

      surfacePos[ix + 0] = surfaceBase[ix + 0] = _p.x;
      surfacePos[ix + 1] = surfaceBase[ix + 1] = _p.y;
      surfacePos[ix + 2] = surfaceBase[ix + 2] = _p.z;

      surfaceNrm[ix + 0] = _n.x;
      surfaceNrm[ix + 1] = _n.y;
      surfaceNrm[ix + 2] = _n.z;

      surfacePhase[i] = Math.random() * Math.PI * 2;

      _col.copy(heartPink);
      const w = 0.50 + Math.random() * 0.30;
      surfaceCol[ix + 0] = _col.r * w;
      surfaceCol[ix + 1] = _col.g * w;
      surfaceCol[ix + 2] = _col.b * w;
    }

    surfaceGeo.setAttribute("position", new THREE.BufferAttribute(surfacePos, 3));
    surfaceGeo.setAttribute("color", new THREE.BufferAttribute(surfaceCol, 3));

    const surfaceMat = new THREE.PointsMaterial({
      map: whiteSprite,
      transparent: true,
      opacity: 0.58,
      alphaTest: 0.06,
      depthWrite: true,
      blending: THREE.AdditiveBlending,
      size: 0.046,
      sizeAttenuation: true,
      vertexColors: true,
    });

    const surfacePoints = new THREE.Points(surfaceGeo, surfaceMat);
    surfacePoints.frustumCulled = false;
    surfacePoints.renderOrder = 10;
    heart.add(surfacePoints);

    // 2-2) 外層 halo：白色粒子沿法線外擴（輪廓更清楚）
    const haloCount = isMobile ? 1800 : 3400;

    const haloGeo = new THREE.BufferGeometry();
    const haloPos = new Float32Array(haloCount * 3);
    const haloBase = new Float32Array(haloCount * 3);
    const haloNrm = new Float32Array(haloCount * 3);
    const haloPhase = new Float32Array(haloCount);
    const haloCol = new Float32Array(haloCount * 3);

    for (let i = 0; i < haloCount; i++) {
      const ix = i * 3;
      sampler.sample(_p, _n);

      const expand = 1.10 + Math.random() * 1.65;
      _p.addScaledVector(_n, expand);

      haloPos[ix + 0] = haloBase[ix + 0] = _p.x;
      haloPos[ix + 1] = haloBase[ix + 1] = _p.y;
      haloPos[ix + 2] = haloBase[ix + 2] = _p.z;

      haloNrm[ix + 0] = _n.x;
      haloNrm[ix + 1] = _n.y;
      haloNrm[ix + 2] = _n.z;

      haloPhase[i] = Math.random() * Math.PI * 2;

      _col.copy(haloWhite);
      const w = 0.11 + Math.random() * 0.17;
      haloCol[ix + 0] = _col.r * w;
      haloCol[ix + 1] = _col.g * w;
      haloCol[ix + 2] = _col.b * w;
    }

    haloGeo.setAttribute("position", new THREE.BufferAttribute(haloPos, 3));
    haloGeo.setAttribute("color", new THREE.BufferAttribute(haloCol, 3));

    const haloMat = new THREE.PointsMaterial({
      map: whiteSprite,
      transparent: true,
      opacity: 0.14,
      alphaTest: 0.01,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      size: 0.145,
      sizeAttenuation: true,
      vertexColors: true,
    });

    const haloPoints = new THREE.Points(haloGeo, haloMat);
    haloPoints.frustumCulled = false;
    haloPoints.renderOrder = 11;
    heart.add(haloPoints);

    // 3) 白色粒子環繞：繞著愛心中心做軌道運動（愛心本體不旋轉）
    const orbitCount = isMobile ? 300 : 520;
    const orbitGeo = new THREE.BufferGeometry();
    const orbitPos = new Float32Array(orbitCount * 3);
    const orbitCol = new Float32Array(orbitCount * 3);
    const orbitU = new Float32Array(orbitCount * 3);
    const orbitV = new Float32Array(orbitCount * 3);
    const orbitAxis = new Float32Array(orbitCount * 3);
    const orbitR = new Float32Array(orbitCount);
    const orbitW = new Float32Array(orbitCount);
    const orbitPhase = new Float32Array(orbitCount);
    const orbitOffset = new Float32Array(orbitCount);

    const _axis = new THREE.Vector3();
    const _u = new THREE.Vector3();
    const _v = new THREE.Vector3();
    const _up = new THREE.Vector3(0, 1, 0);

    for (let i = 0; i < orbitCount; i++) {
      const ix = i * 3;

      _axis.set((Math.random() - 0.5) * 0.35, (Math.random() - 0.5) * 0.25, 1).normalize();
      _u.crossVectors(_axis, _up);
      if (_u.lengthSq() < 1e-6) _u.set(1, 0, 0);
      _u.normalize();
      _v.crossVectors(_axis, _u).normalize();

      orbitAxis[ix + 0] = _axis.x;
      orbitAxis[ix + 1] = _axis.y;
      orbitAxis[ix + 2] = _axis.z;

      orbitU[ix + 0] = _u.x;
      orbitU[ix + 1] = _u.y;
      orbitU[ix + 2] = _u.z;

      orbitV[ix + 0] = _v.x;
      orbitV[ix + 1] = _v.y;
      orbitV[ix + 2] = _v.z;

      orbitR[i] = heartRadius * (1.26 + Math.random() * 0.42);
      orbitW[i] = (Math.random() < 0.5 ? -1 : 1) * (0.55 + Math.random() * 0.75);
      orbitPhase[i] = Math.random() * Math.PI * 2;
      orbitOffset[i] = (Math.random() - 0.5) * (heartRadius * 0.28);

      _col.copy(haloWhite);
      const w = 0.16 + Math.random() * 0.22;
      orbitCol[ix + 0] = _col.r * w;
      orbitCol[ix + 1] = _col.g * w;
      orbitCol[ix + 2] = _col.b * w;

      const a0 = orbitPhase[i];
      const ca0 = Math.cos(a0);
      const sa0 = Math.sin(a0);
      orbitPos[ix + 0] = _u.x * (ca0 * orbitR[i]) + _v.x * (sa0 * orbitR[i]) + _axis.x * orbitOffset[i];
      orbitPos[ix + 1] = _u.y * (ca0 * orbitR[i]) + _v.y * (sa0 * orbitR[i]) + _axis.y * orbitOffset[i];
      orbitPos[ix + 2] = _u.z * (ca0 * orbitR[i]) + _v.z * (sa0 * orbitR[i]) + _axis.z * orbitOffset[i];
    }

    orbitGeo.setAttribute("position", new THREE.BufferAttribute(orbitPos, 3));
    orbitGeo.setAttribute("color", new THREE.BufferAttribute(orbitCol, 3));

    const orbitMat = new THREE.PointsMaterial({
      map: whiteSprite,
      transparent: true,
      opacity: 0.66,
      alphaTest: 0.02,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      size: 0.092,
      sizeAttenuation: true,
      vertexColors: true,
    });

    const orbitPoints = new THREE.Points(orbitGeo, orbitMat);
    orbitPoints.frustumCulled = false;
    orbitPoints.renderOrder = 12;
    heart.add(orbitPoints);

    // ---------- Animation ----------
    const clock = new THREE.Clock();

    function heartbeatScale(t) {
      const speed = 3.2;
      const b1 = Math.pow(Math.max(0, Math.sin(t * speed)), 6);
      const b2 = Math.pow(Math.max(0, Math.sin(t * speed + 1.1)), 10);
      const relax = Math.pow(Math.max(0, Math.sin(t * speed + Math.PI * 0.75)), 2);
      return 1 + 0.11 * (b1 + 0.6 * b2) - 0.045 * relax;
    }

    function animate() {
      requestAnimationFrame(animate);

      const dt = Math.min(0.05, clock.getDelta());
      const t = clock.elapsedTime;

      // 愛心心跳（僅縮放，不旋轉）
      const pulse = heartbeatScale(t);
      heart.scale.setScalar(baseScale * pulse);

      // Bloom 跟著心跳呼吸（避免 additive 疊太亮把紅色洗白）
      const bloomKick = THREE.MathUtils.clamp((pulse - 1) / 0.11, 0, 1);
      bloomPass.strength = 0.38 + bloomKick * 0.26;
      bloomPass.radius = 0.33 + bloomKick * 0.05;

      // 背景粒子漂浮（wrap）
      const pos = ambientGeo.attributes.position.array;
      for (let i = 0; i < ambientCount; i++) {
        const ix = i * 3;
        pos[ix + 0] += ambientVel[ix + 0] * (dt * 60);
        pos[ix + 1] += ambientVel[ix + 1] * (dt * 60);
        pos[ix + 2] += ambientVel[ix + 2] * (dt * 60);

        if (pos[ix + 0] > half.x) pos[ix + 0] = -half.x;
        if (pos[ix + 0] < -half.x) pos[ix + 0] = half.x;
        if (pos[ix + 1] > half.y) pos[ix +  1] = -half.y;
        if (pos[ix + 1] < -half.y) pos[ix + 1] = half.y;
        if (pos[ix + 2] > ambientZMax) pos[ix + 2] = ambientZMin;
        if (pos[ix + 2] < ambientZMin) pos[ix + 2] = ambientZMax;
      }
      ambientGeo.attributes.position.needsUpdate = true;

      // 愛心表面粒子：沿法線做非常小的呼吸抖動（保持輪廓、避免變雲）
      const surfaceArr = surfaceGeo.attributes.position.array;
      const haloArr = haloGeo.attributes.position.array;

      const surfaceAmp = 0.10 + bloomKick * 0.06;
      const haloAmp = 0.18 + bloomKick * 0.10;
      const surfaceFreq = 1.10;
      const haloFreq = 1.25;

      for (let i = 0; i < surfaceCount; i++) {
        const ix = i * 3;
        const s = Math.sin(t * surfaceFreq + surfacePhase[i]);
        const amp = surfaceAmp * (0.5 + 0.5 * s);
        surfaceArr[ix + 0] = surfaceBase[ix + 0] + surfaceNrm[ix + 0] * amp;
        surfaceArr[ix + 1] = surfaceBase[ix + 1] + surfaceNrm[ix + 1] * amp;
        surfaceArr[ix + 2] = surfaceBase[ix + 2] + surfaceNrm[ix + 2] * amp;
      }
      surfaceGeo.attributes.position.needsUpdate = true;

      for (let i = 0; i < haloCount; i++) {
        const ix = i * 3;
        const s = Math.sin(t * haloFreq + haloPhase[i]);
        const amp = haloAmp * (0.5 + 0.5 * s);
        haloArr[ix + 0] = haloBase[ix + 0] + haloNrm[ix + 0] * amp;
        haloArr[ix + 1] = haloBase[ix + 1] + haloNrm[ix + 1] * amp;
        haloArr[ix + 2] = haloBase[ix + 2] + haloNrm[ix + 2] * amp;
      }
      haloGeo.attributes.position.needsUpdate = true;

      // 白色軌道粒子：繞著中心運動（加一點軸向起伏）
      orbitMat.opacity = 0.60 + bloomKick * 0.23;

      const orbitArr = orbitGeo.attributes.position.array;
      const orbitBob = heartRadius * 0.06;

      for (let i = 0; i < orbitCount; i++) {
        const ix = i * 3;
        const a = t * orbitW[i] + orbitPhase[i];
        const ca = Math.cos(a);
        const sa = Math.sin(a);
        const r = orbitR[i];
        const off = orbitOffset[i] + Math.sin(t * 1.3 + orbitPhase[i]) * orbitBob;

        orbitArr[ix + 0] = orbitU[ix + 0] * (ca * r) + orbitV[ix + 0] * (sa * r) + orbitAxis[ix + 0] * off;
        orbitArr[ix + 1] = orbitU[ix + 1] * (ca * r) + orbitV[ix + 1] * (sa * r) + orbitAxis[ix + 1] * off;
        orbitArr[ix + 2] = orbitU[ix + 2] * (ca * r) + orbitV[ix + 2] * (sa * r) + orbitAxis[ix + 2] * off;
      }
      orbitGeo.attributes.position.needsUpdate = true;

      composer.render();
    }
    animate();

    // 若能跑到這裡，代表 three / addons 載入成功，隱藏提示
    const hintEl = document.getElementById("hint");
    if (hintEl) {
      hintEl.style.opacity = "0";
      hintEl.style.transition = "opacity 600ms ease";
      hintEl.style.pointerEvents = "none";
      window.setTimeout(() => hintEl.remove(), 900);
    }

    // ---------- Resize ----------
    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const dpr = Math.min(window.devicePixelRatio || 1, dprCap);

      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      camera.lookAt(0, 0, 0);

      renderer.setPixelRatio(dpr);
      renderer.setSize(w, h);
      composer.setPixelRatio(dpr);
      composer.setSize(w, h);

      bloomPass.setSize(w, h);
    }, { passive: true });
  </script>
</body>
</html>
